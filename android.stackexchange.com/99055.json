{"CreationDate":"\/Date(1404559337007)\/","AverageQuestionsPerDay":0,"AverageAnswersPerDay":0,"AveragePostsPerDay":0,"Views":2,"UpVotes":0,"DownVotes":0,"AccountId":99055,"LastAccessDate":"\/Date(1454458424327)\/","Reputation":101,"PostStats":{"PostsMade":0,"TotalViews":0,"Questions":1,"TotalWordsForQuestions":26,"TotalWordsForAnswers":0,"TotalTitleWordCount":10,"HighestScoredQuestion":0,"LowestScoredQuestion":0,"TotalCommentsOnQuestions":0,"Answers":0,"HighestScoredAnswer":0,"LowestScoredAnswer":0,"TotalCommentsOnPosts":0,"TotalCommentsOnAnswers":0,"TotalAcceptedAnswers":0,"AverageWordsPerAnswer":0,"AverageViewsPerPost":0,"AverageAcceptedAnswers":0,"LongestQuestionWordCount":26,"ShortestQuestionWordCount":26,"LongestAnswerWordCount":0,"ShortestAnswerWordCount":0,"LongestQuestionTitleWordCount":10,"AverageQuestionTitleWordCount":0,"AverageWordsPerQuestion":26,"QuestionIds":[103148],"AnswerIds":[],"Id":null},"BadgeStats":{"TotalBadges":0,"TotalTagBadges":0,"Badges":[],"Id":null,"MostEarnedBadge":null},"CommentStats":{"Comments":0,"LongestCommentWordCount":0,"ShortestCommentWordCount":0,"AverageCommentWordCount":0,"AverageCommentScore":0,"TotalCommentWordCount":0,"HighestScoredComment":0,"LowestScoredComment":0,"CommentScores":[],"Id":null},"Name":"itorres","Id":"android.stackexchange.com-99055","AboutMe":"<blockquote>\n  <ul>\n  <li><strong>Rule 1.</strong>  You can’t tell where a program is going to spend its time.  Bottlenecks occur in surprising\n  places, so don’t try to second guess and put in a speed hack until you’ve proven that’s where the bottleneck\n  is.  </li>\n  <li><strong>Rule 2.</strong>  Measure.  Don’t tune for speed until you’ve measured, and even then don’t unless one part\n  of the code\n  overwhelms\n  the rest.</li>\n  <li>Rule 3.  Fancy algorithms are slow when\n  n\n  is small, and\n  n\n  is usually small.  Fancy algorithms have\n  big constants.  Until you know that\n  n\n  is frequently going to be big, don’t get fancy.  (Even if\n  n\n  does get\n  big, use Rule 2 first.)  For example, binary trees are always faster than splay trees for workaday problems.</li>\n  <li><strong>Rule 4.</strong>  Fancy algorithms are buggier than simple ones, and they’re much harder to implement.  Use\n  simple algorithms as well as simple data structures.<br>\n  The following data structures are a complete list for almost all practical programs: array, linked list, hash table, binary tree.<br>\n  Of course, you must also be prepared to collect these into compound data structures.  For instance, a symbol table might be implemented as a hash table containing linked lists of arrays of characters.</li>\n  <li><strong>Rule 5.</strong>  Data dominates.  If you’ve chosen the right data structures and organized  things well, the\n  algorithms will almost always be self-evident.  Data structures, not algorithms, are central to programming.\n  (See Brooks p. 102.)</li>\n  <li><strong>Rule 6.</strong>  There is no Rule 6.</li>\n  </ul>\n  \n  <p><em>-- Rob Pike, <a href=\"http://www.literateprogramming.com/pikestyle.pdf\" rel=\"nofollow\">Programming in C</a>: Complexity</em></p>\n</blockquote>\n","Location":"Catalonia, Spain"}
